let lastUiUpdate = 0; // Para controlar o flood da UI

conn.on('data', async d => {
    if (d.file) {
        if (!writer) {
            receivedBytes = 0;
            document.getElementById('rx-area').style.display = 'block';
            
            // Criamos o stream de escrita
            fileStream = window.streamSaver.createWriteStream(d.name, { size: d.totalSize });
            writer = fileStream.getWriter();
        }

        const uint8 = new Uint8Array(d.file);
        
        // MELHORIA: Não usamos 'await' aqui para não travar a recepção do próximo chunk
        // O writer.write cria uma fila interna (queuing strategy)
        writer.write(uint8);
        
        receivedBytes += uint8.length;

        // MELHORIA: Só atualiza a interface a cada 100ms (evita lentidão por renderização)
        let now = Date.now();
        if (now - lastUiUpdate > 100 || d.last) {
            const pct = Math.round((receivedBytes / d.totalSize) * 100) + "%";
            document.getElementById('rx-bar').style.width = pct;
            document.getElementById('rx-pct').innerText = pct;
            lastUiUpdate = now;
        }

        if (d.last) {
            // No último pacote, garantimos que tudo foi escrito antes de fechar
            setTimeout(async () => {
                if (writer) {
                    await writer.close();
                    writer = null;
                }
                setTimeout(() => { 
                    document.getElementById('rx-area').style.display = 'none'; 
                }, 2000);
            }, 1000);
        }
    }
});
